Описание работы для конкурса Intel® Acceler8
============================================
:author: Александр Соловец
:toc:

:numbered:

Описание поставленной задачи
----------------------------

Условия задачи
~~~~~~~~~~~~~~
Задача конкурса состоит в том, чтобы в заданной матрице, состоящей из целых
чисел, найти подматрицу с максимальной возможной суммой её элементов. В данном
случае 'подматрицой' считается матрица образованная из подмножества строк и
столбцов исходной матрицы, идущих подряд. Иногда этот термин путают с
'минором'. В случае, если ответов может быть несколько, следует вывести любой
из них.

Решение должно быть представленно в виде программы, которая принимает два
параметра -- имена входного и выходного файлов.

Формат входных данных
~~~~~~~~~~~~~~~~~~~~~
Первым элементом входных данных является число *T*, обозначающее количество
тестов. Следом идут *T* строк, содержащих шесть чисел: *N*, *M*, *S*, *a*,
*b*, *m*. Первые два -- число строк и столбцов в исходной матрице, остальные
четыре -- параметры генератора псевдо-случайных чисел.

Исходная матрица *A* строится при помощи следующего алгоритма:

[source,c]
------------------------------------------
int sum = 0;
int seed = seed0;
size_t dstSize = M * N;

int mean, remainder;

for (i = 0; i < dstSize; i += 1) {
	seed = PRNG(seed, a, b, m);
	A[i] = seed;
	sum += seed;
}

mean = sum / (signed) dstSize;
remainder = sum - mean * dstSize;
mean += (remainder * 2 > (signed) dstSize ? (1) : (0);
mean -= (remainder * 2 < -(signed) dstSize ? (1) : (0);

for (i = 0; i < dstSize; i += 1)
{
	A[i] -= mean;
}
------------------------------------------

Значения *seed*, *a*, *b* и *m* берутся из входных данных. Функция +PRNG+
выглядит следующим образом:

[source, c]
------------------------------
PRNG(seed, a, b , m)
{
	return (a * seed + b) % m;
}
------------------------------

Ограничения для входных параметров:

- +1 ≤ *T* ≤ 1000+
- +1 ≤ *N*, *M*, *S*, *a*, *b*, *m* ≤ 20000+

Пример входного файла:

---------------
2
4 3 10 3 4 17
14 31 11 4 5 18
---------------

Формат выходных данных
~~~~~~~~~~~~~~~~~~~~~~
Для каждого теста входных данных программа должна вывести строку, содер

Пример выходного файла:

----------------------
Case #1: 0 2 3 2 17 4
Case #2: 0 4 5 9 18 36
----------------------

Алгоритм решения задачи
-----------------------

Последовательный алгоритм
~~~~~~~~~~~~~~~~~~~~~~~~~
В качестве основного алгоритма решения задачи был взял модифицированный
http://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane.27s_algorithm[алгоритм Джея Кадана].

Решение имеет сложность O(*N²M*).

Параллельный алгоритм
~~~~~~~~~~~~~~~~~~~~~
`в том числе метод распараллеливания и обоснование его выбора необходимые
изменения последовательного алгоритма использованные языки и средства
распараллеливания идеи которые помогли перейти от линейного алгоритма к
параллельному обзор проблемб с которыми пришлось столкнуться и путей их
решения и так далее`

В качестве средств создания был выбран интерфейс +OpenMP+. Во-первых, этот
интерфейс является переносимым и поддерживается компиляторами +GNU+ и +Intel+
языка программирования +С+.

В качетсве альтернативного варианта распараллеливания рассматривался
переборный алгоритм, который работает за O(*N²M²*). Это было связано с тем,
что при использовании максимального количества ядер (40) наблюдалось снижение
производительности, которое может быть связано с
+NUMA+-архитектуройю-архитектурой либо с тем, что распарарллеливание по
внешнему циклу имеет очень большой недостаток -- если ядра используют общий
кэш, то постоянный переход от строки к строке (матрицы) ведёт к его
инвалидации. К сожалению, это очень трудно проверить без специальных
инструментов, которыми я не смог воспользоваться ввиду огромной задержки между
рабочим комьютером и MTL.

.Поворот матрицы и удаление лишнего копирования.
image::img/step03.png[align="center"]

.Заголовок.
image::img/step03.png["Шаг 2",align="center"]

.Заголовок.
image::img/step03.png["Шаг 3",align="center"]

.Избавление от критических секций.
image::img/step03.png["Шаг 4",align="center"]

Анализ достигнутых и предполагаемых результатов
-----------------------------------------------
На основе измерения времени работы параллельного алгортма можно сделать вывод,
что данное решение достаточно эффективно использует интерфейс +OpenMP+ и
позволяет достичь прироста в производительности, сравнимого с линейным.
Оно также доказывает, что помимо правильного использования средств
параллелизации необходимо граммотно организовывать параллельный доступ к
памяти и по возможности сводить запись в общую память к минумуму.

:numbered!:

[appendix]
Исходный код
------------
[source,c,n]
-----------------------
include::../src/msp.c[]
-----------------------
[appendix]
Список использованных инструментов
----------------------------------
- http://gcc.gnu.org/[+GNU C compiler+]
- http://www.gnu.org/s/bash/[+GNU Bash+]
- http://www.perl.org/[+Perl+]
- http://www.methods.co.nz/asciidoc/[+AsciiDoc+]
- http://www.gnuplot.info/[+gnuplot+]
- http://www.gnu.org/s/src-highlite/[+source-highlight+]
- http://www.gnu.org/s/coreutils/[+GNU Coreutils+]
- http://www.gnu.org/s/make/[+GNU Make+]
