Описание работы для конкурса Intel® Acceler8
============================================
:author: Александр Соловец
:toc:

:numbered:

Описание поставленной задачи
----------------------------

Условия задачи
~~~~~~~~~~~~~~
Задача конкурса состоит в том, чтобы в заданной матрице, состоящей из целых
чисел, найти подматрицу с максимальной возможной суммой её элементов. В данном
случае 'подматрицой' считается матрица образованная из подмножества строк и
столбцов исходной матрицы, идущих подряд. Иногда этот термин путают с
'минором'. В случае, если ответов может быть несколько, следует вывести любой
из них.

Решение должно быть представленно в виде программы, которая принимает два
параметра -- имена входного и выходного файлов.

Формат входных данных
~~~~~~~~~~~~~~~~~~~~~
Первым элементом входных данных является число *T*, обозначающее количество
тестов. Следом идут *T* строк, содержащих шесть чисел: *N*, *M*, *S*, *a*,
*b*, *m*. Первые два -- число строк и столбцов в исходной матрице, остальные
четыре -- параметры генератора псевдо-случайных чисел.

Исходная матрица *A* строится при помощи следующего алгоритма:

[source,c]
------------------------------------------
int sum = 0;
int seed = seed0;
size_t dstSize = M * N;

int mean, remainder;

for (i = 0; i < dstSize; i += 1) {
	seed = PRNG(seed, a, b, m);
	A[i] = seed;
	sum += seed;
}

mean = sum / (signed) dstSize;
remainder = sum - mean * dstSize;
mean += (remainder * 2 > (signed) dstSize ? (1) : (0);
mean -= (remainder * 2 < -(signed) dstSize ? (1) : (0);

for (i = 0; i < dstSize; i += 1)
{
	A[i] -= mean;
}
------------------------------------------

Значения *seed*, *a*, *b* и *m* берутся из входных данных. Функция +PRNG+
выглядит следующим образом:

[source, c]
------------------------------
PRNG(seed, a, b , m)
{
	return (a * seed + b) % m;
}
------------------------------

Ограничения для входных параметров:

- +1 ≤ *T* ≤ 1000+
- +1 ≤ *N*, *M*, *S*, *a*, *b*, *m* ≤ 20000+

Пример входного файла:

---------------
2
4 3 10 3 4 17
14 31 11 4 5 18
---------------

Формат выходных данных
~~~~~~~~~~~~~~~~~~~~~~
Для каждого теста в выходной файл нужно вывести строку "+Case #x:+ ", за которой
следуют 6 целых чисел (через пробел) и символ переноса строки.

Первые 4 числа — две пары координат, задающих подматрицу с максимальной суммой
элементов (в первой паре оба числа должны быть меньше или равны
соответственным числам во второй паре, т.е. сначала описывается координаты
левого верхнего, а потом правого нижнего угла). В каждой паре первое число —
номер строки, а второе число — номер столбца (нумерация начинается с нуля).
Если вы нашли несколько подматриц с одинаковой максимальной суммой элементов,
выведите координаты любой из них.

Последние 2 числа — сумма элементов в найденной подматрице и площадь этой
подматрицы соответственно.

Весь вывод должен идти в выходной файл, имя которого задается вторым
параметром командной строки.

Пример выходного файла:

----------------------
Case #1: 0 2 3 2 17 4
Case #2: 0 4 5 9 18 36
----------------------

Алгоритм решения задачи
-----------------------

Последовательный алгоритм
~~~~~~~~~~~~~~~~~~~~~~~~~
В качестве основного алгоритма решения задачи был взял модифицированный
http://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane.27s_algorithm[алгоритм
Джея Кадана], сложность которого составляет O(*N²M*).

Параллельный алгоритм
~~~~~~~~~~~~~~~~~~~~~
В качестве средств создания был выбран интерфейс +OpenMP+. Во-первых, этот
интерфейс является переносимым и поддерживается компиляторами +GNU+ и +Intel+
языка программирования +С+.

.Первая рабочая версия.
image::img/data1.png[align="center"]

.Заголовок.
.Поворот матрицы и удаление лишнего копирования.
image::img/data2.png[align="center"]

.Удаление критических секций.
image::img/data3.png[align="center"]

.Мелкие оптимизации.
image::img/data4.png[align="center"]

.20.
image::img/data5.png[align="center"]

.10.
image::img/data6.png[align="center"]

.30.
image::img/data7.png[align="center"]

.50.
image::img/data8.png[align="center"]

Анализ достигнутых и предполагаемых результатов
-----------------------------------------------
На основе измерения времени работы параллельного алгортма можно сделать вывод,
что данное решение достаточно эффективно использует интерфейс +OpenMP+ и
позволяет достичь прироста в производительности, сравнимого с линейным.
Оно также доказывает, что помимо правильного использования средств
параллелизации необходимо граммотно организовывать параллельный доступ к
памяти и сводить к минумуму количество записей в общую память. Особенно это
важно для машин с +NUMA+.

:numbered!:

[appendix]
Исходный код
------------
[source,c,n]
-----------------------
include::../src/msp.c[]
-----------------------
[appendix]
Список использованных инструментов
----------------------------------
- http://gcc.gnu.org/[+GNU C compiler+]
- http://www.gnu.org/s/bash/[+GNU Bash+]
- http://www.perl.org/[+Perl+]
- http://www.methods.co.nz/asciidoc/[+AsciiDoc+]
- http://www.gnuplot.info/[+gnuplot+]
- http://www.gnu.org/s/src-highlite/[+source-highlight+]
- http://www.gnu.org/s/coreutils/[+GNU Coreutils+]
- http://www.gnu.org/s/make/[+GNU Make+]
